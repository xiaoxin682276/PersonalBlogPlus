---
title: Redis 面试题高频总结（问答实录）
description: 精炼易记的 Redis 高频面试 Q&A 总结
slug: redis-interview-qa
date: 2025-10-29 00:00:00+0000
image: redis-qa-cover.jpg
categories:
    - 数据库
    - Redis
---

### Redis 高频面试问答总结

以下内容整理自 Redis 在面试中最常见的高频问题，以问答形式呈现，帮助更好地记忆与理解。

---

#### 1. 什么是缓存穿透？怎么解决？
**答**：缓存穿透指查询一定不存在的数据，由于数据库查不到，也不会写入缓存，导致每次请求都打到 DB。  
**解决方案**：使用 **布隆过滤器** 拦截无效请求。

---

#### 2. 你能介绍一下布隆过滤器吗？
**答**：布隆过滤器用来判断元素是否在集合中。底层是一个 bit 数组，通过多次 hash 把 key 映射到不同位置并置为 1。  
查找时只要有一位是 0，就说明不存在。虽然有少量误判（一般小于 5%），但能极大节省空间。我们项目用的是 **Redisson 的布隆过滤器实现**。

---

#### 3. 什么是缓存击穿？怎么解决？
**答**：缓存击穿是指某个热点 key 过期瞬间，大量并发请求同时访问，导致都去查 DB。  
**解决办法**：
1. 使用 **互斥锁（SETNX）** 控制只有一个线程加载数据；
2. 使用 **逻辑过期**：缓存中保存过期时间字段，过期后由后台线程异步更新。

---

#### 4. 什么是缓存雪崩？怎么解决？
**答**：雪崩是大量 key 同时过期，所有请求都访问 DB，造成压力暴增。  
**解决办法**：给缓存时间加上随机值，让 key 的过期时间分散。

---

#### 5. Redis 和 MySQL 如何保持一致性？
**答**：两种方案：
- **强一致性**：用 **Redisson 读写锁**，读写互斥；
- **最终一致性**：用 **Canal 监听 MySQL binlog**，实时更新 Redis。

---

#### 6. Redis 的持久化方式有哪些？
**答**：有两种：
- **RDB**（快照）：定期将内存数据写入磁盘，恢复快但可能丢数据；
- **AOF**（追加日志）：记录写命令，恢复完整但速度稍慢。  
  实际项目中多采用 **RDB + AOF 混合持久化**。

---

#### 7. Redis 的过期删除策略？
**答**：两种：
- **惰性删除**：访问时检查是否过期；
- **定期删除**：后台定时扫描部分 key 删除。  
  Redis 实际上是两者结合使用。

---

#### 8. Redis 的内存淘汰策略？
**答**：常见的有：
- `noeviction`：内存满时报错；
- `allkeys-lru`：淘汰最近最少使用的数据；
- `allkeys-lfu`：淘汰访问频率最低的。  
  我们一般设置 `allkeys-lru` 保证热点数据留存。

---

#### 9. Redis 分布式锁如何实现？
**答**：通过 `SETNX` 实现互斥；也可以用 **Redisson**，支持自动续期（看门狗机制）、可设置超时、可重入，性能更好。

---

#### 10. Redisson 分布式锁能保证主从一致吗？
**答**：不能。主节点宕机后，锁状态可能不同步到从节点。  
可使用 **红锁（RedLock）** 同时在多个 Redis 节点加锁，要求大多数节点成功，但性能较差，一般不建议生产使用。

---

#### 11. 业务需要强一致性该怎么办？
**答**：如果业务对一致性要求极高，可以使用 **ZooKeeper 分布式锁**，它能提供强一致保证。

---

#### 12. Redis 集群有哪些模式？
**答**：主要有三种：
1. **主从复制**（读写分离）；
2. **哨兵模式**（自动故障转移）；
3. **分片集群**（海量数据分布式存储）。

---

#### 13. 主从同步的流程？
**答**：分两步：
- **全量同步**：slave 第一次连接时，master 生成 RDB 并传输；
- **增量同步**：slave 重连后，通过 offset 获取主节点的增量命令日志。

---

#### 14. Redis 脑裂怎么解决？
**答**：脑裂是主从间网络分区，出现两个 master。  
可通过配置：
- 设置最少从节点数；
- 限制主从复制延迟阈值，防止数据丢失。

---

#### 15. 分片集群数据如何存储？
**答**：Redis 集群引入了 **16384 个哈希槽**，key 通过 `CRC16(key) % 16384` 定位到对应节点，实现负载均衡与高并发。

---

#### 16. Redis 为什么这么快？
**答**：主要因为：
1. 完全基于内存；
2. 单线程避免锁竞争；
3. 使用 **I/O 多路复用（epoll）**；
4. 核心命令执行流程极短。

---

#### 17. 什么是 I/O 多路复用？
**答**：一个线程同时监听多个 socket，当某个 socket 可读/写时统一处理，不用轮询。  
Redis 使用 **epoll + 事件驱动模型**，高效处理成千上万的连接。

---

### 💬 面试总结
Redis 面试的核心在于三点：
1. **缓存问题三兄弟**：穿透、击穿、雪崩；
2. **一致性与持久化**：RDB、AOF、锁机制；
3. **高可用与高性能**：主从、哨兵、分片、I/O 模型。